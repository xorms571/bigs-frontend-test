# Bigs Frontend Test Project

이 프로젝트는 Next.js, TypeScript, Tailwind CSS를 사용하여 구축된 간단한 게시판 애플리케이션입니다. 사용자 인증 기능과 게시글 CRUD(생성, 읽기, 수정, 삭제) 기능을 포함하고 있습니다.

## ✨ 주요 기능

- **사용자 인증**:
  - 회원가입 및 로그인
  - JWT (Access/Refresh Token) 기반 인증
  - `HttpOnly` 쿠키를 사용한 안전한 토큰 관리
  - **액세스 토큰 만료 시 자동 갱신**:
    - API 요청 시 액세스 토큰이 만료되어 `401 Unauthorized` 응답을 받으면, 자동으로 `/api/auth/refresh` 엔드포인트를 호출하여 토큰 갱신을 시도합니다.
    - 토큰 갱신에 성공하면, 실패했던 원래 요청을 새로운 토큰으로 재시도하여 중단 없는 사용자 경험을 제공합니다.
    - 만약 리프레시 토큰마저 만료되어 갱신에 실패하면, 사용자의 인증 상태를 초기화하고 로그인 페이지로 리디렉션하여 다시 로그인하도록 유도합니다.
- **게시판**:
  - 게시글 목록 조회 (페이지네이션 포함)
  - 게시글 상세 조회
  - 게시글 작성 및 수정
- **기타**:
  - 홈페이지 접속 시 게시판 목록으로 자동 리디렉션

## 🛠️ 기술 스택

- **프레임워크**: [Next.js](https://nextjs.org/) (App Router)
- **언어**: [TypeScript](https://www.typescriptlang.org/)
- **상태 관리**: [Zustand](https://github.com/pmndrs/zustand)
- **스타일링**: [Tailwind CSS](https://tailwindcss.com/)
- **UI 컴포넌트**: 재사용 가능한 자체 컴포넌트 (`src/components`)

## 🤔 아키텍처 결정

### Fetch API 사용 이유

이 프로젝트에서는 `axios`와 같은 서드파티 라이브러리 대신 네이티브 `fetch` API를 사용하여 HTTP 요청을 처리합니다. 여기에는 몇 가지 중요한 이유가 있습니다.

1.  **의존성 최소화**: `fetch`는 브라우저와 Node.js 환경에 내장된 기능이므로, 별도의 라이브러리를 설치할 필요가 없어 프로젝트의 전체 번들 크기를 줄이는 데 도움이 됩니다.

2.  **Next.js와의 긴밀한 통합**: Next.js App Router는 네이티브 `fetch` API를 확장하여 서버 컴포넌트에서의 데이터 캐싱 및 재검증(revalidation) 전략을 유연하게 제어할 수 있도록 지원합니다. 예를 들어, `getBoards` 함수에서 사용된 `cache: 'no-store'` 옵션은 `fetch`를 통해 서버 사이드 렌더링(SSR)을 구현하는 Next.js의 공식적인 방법입니다. `axios`는 이러한 Next.js의 고유 기능을 직접 지원하지 않습니다.

3.  **최신 웹 표준**: `fetch`는 최신 웹 표준 API로, 지속적으로 발전하고 있으며 최신 웹 개발 패러다임에 더 잘 부합합니다.

이러한 이유로, 특히 Next.js App Router 환경에서는 `fetch`를 사용하는 것이 더 효율적이고 권장되는 접근 방식입니다.

## 📁 프로젝트 구조

```
C:/Users/UserK/Desktop/bigs frontend test/bigs-frontend-test/
├── public/              # 정적 에셋 (이미지, 폰트 등)
├── src/
│   ├── app/
│   │   ├── api/         # 백엔드 API 라우트 (BFF)
│   │   │   ├── auth/    # 인증 관련 API
│   │   │   └── boards/  # 게시판 관련 API
│   │   ├── boards/      # 게시판 페이지
│   │   ├── login/       # 로그인 페이지
│   │   ├── signup/      # 회원가입 페이지
│   │   ├── layout.tsx   # 전역 레이아웃
│   │   └── page.tsx     # 홈페이지 (게시판으로 리디렉션)
│   ├── components/      # 재사용 가능한 UI 컴포넌트
│   ├── hooks/           # 커스텀 훅
│   ├── store/           # Zustand를 사용한 전역 상태 관리
│   ├── types/           # 공용 타입 정의
│   └── utils/           # 유틸리티 함수 (API 호출 등)
├── next.config.ts       # Next.js 설정
├── package.json         # 프로젝트 의존성 및 스크립트
└── tailwind.config.js   # Tailwind CSS 설정
```

### API 라우트 (BFF)

이 프로젝트의 Next.js 서버는 외부 API 서버와 통신하는 BFF(Backend For Frontend) 역할을 합니다. 클라이언트는 Next.js 서버의 API 라ው트와 통신하며, 서버는 외부 API(`https://front-mission.bigs.or.kr`)로 요청을 전달하고 응답을 처리합니다. 이 구조는 API 키나 민감한 정보를 클라이언트에 노출하지 않고 안전하게 처리하는 데 도움을 줍니다.

## ✨ 하이브리드 렌더링: 게시판 목록 페이지

게시판 목록 페이지(`src/app/boards`)에는 초기 로딩 성능과 사용자 경험을 개선하기 위해 하이브리드 렌더링 방식이 적용되었습니다.

### 적용 이유

1.  **초기 로딩 속도 개선**: 서버에서 데이터를 미리 가져와 페이지를 완전히 렌더링하므로, 사용자는 로딩 상태 없이 즉시 콘텐츠를 볼 수 있습니다.
2.  **사용자 경험 향상**: 첫 페이지는 서버에서 렌더링되고, 이후 페이지네이션과 같은 동적인 상호작용은 클라이언트에서 처리되어 빠르고 부드러운 화면 전환을 제공합니다.
3.  **검색 엔진 최적화 (SEO)**: 서버에서 렌더링된 HTML에는 게시물 데이터가 포함되어 있어 검색 엔진이 콘텐츠를 쉽게 수집하고 인덱싱할 수 있습니다.

### 적용 방식

하이브리드 렌더링은 Next.js의 서버 컴포넌트와 클라이언트 컴포넌트의 장점을 결합하여 구현되었습니다.

1.  **서버 컴포넌트 (`src/app/boards/page.tsx`)**:
    -   페이지 요청 시 서버에서 `getBoards` 함수를 호출하여 게시판 데이터를 미리 가져옵니다 (`cache: 'no-store'` 옵션을 통해 항상 최신 데이터를 요청).
    -   가져온 데이터(`initialBoardsPage`)를 클라이언트 컴포넌트인 `<BoardsList />`에 props로 전달합니다.

2.  **클라이언트 컴포넌트 (`src/app/boards/components/BoardsList.tsx`)**:
    -   서버로부터 받은 `initialBoardsPage` 데이터를 초기 상태로 사용하여 첫 화면을 렌더링합니다. 이 덕분에 클라이언트에서 별도의 초기 데이터 요청이 발생하지 않습니다.
    -   페이지네이션과 같이 사용자의 상호작용이 발생하면, `useEffect` 훅을 통해 클라이언트 측에서 직접 API를 호출하여 필요한 데이터만 업데이트합니다.

이러한 구조를 통해 초기 진입 시에는 SSR(서버 사이드 렌더링)의 이점을, 페이지 이동 시에는 CSR(클라이언트 사이드 렌더링)의 이점을 모두 활용하여 효율적이고 빠른 사용자 경험을 제공합니다.

### 서버 사이드에서의 토큰 만료 처리

서버 컴포넌트(`page.tsx`)에서 실행되는 초기 데이터 로딩(`getBoards`) 중 액세스 토큰이 만료되었을 경우, 다음과 같이 처리됩니다.

1.  서버에서 `/api/boards`로 데이터를 요청할 때, 만료된 토큰으로 인해 요청이 실패하고 `null`을 반환합니다.
2.  페이지는 `initialBoardsPage` 데이터가 없는 상태(`null`)로 렌더링되어 클라이언트에 전달됩니다.
3.  클라이언트 컴포넌트(`BoardsList.tsx`)는 `initialBoardsPage`가 `null`이므로, 초기 데이터가 없다고 판단합니다.
4.  `useEffect` 훅이 실행되면서 클라이언트 측에서 `fetchWithTokenRefresh` 함수를 통해 데이터 로딩을 시작합니다.
5.  이때 `fetchWithTokenRefresh` 함수가 만료된 액세스 토-큰을 감지하고, 토큰 갱신 절차를 실행합니다.
6.  토큰 갱신이 성공하면 새로운 토큰으로 데이터를 성공적으로 가져와 화면에 목록을 렌더링합니다.

결론적으로, 서버 사이드 렌더링 시점의 토큰 만료는 클라이언트 측의 토큰 갱신 메커니즘에 의해 처리됩니다. 이로 인해 사용자는 잠시 로딩 상태를 보게 될 수 있지만, 별도의 재로그인 없이 자연스럽게 세션이 갱신되고 데이터를 볼 수 있습니다.